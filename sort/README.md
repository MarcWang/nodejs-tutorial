
# 氣泡排序法 ( Bubble Sort )

> 從第一筆開始，每相鄰兩筆比較，大小交換位置，大的在右，小的在左，以此類退，直到最後一筆。 不斷的循環直到都沒有交換為止。

### 時間複雜度 ( Time Complexity )
* Best Case：Ο(n)
* Worst Case：Ο(n2)
* Average Case：Ο(n2)

``` Step1
(8)~(5)~(7)~(2)~(3)~(9)~(4)~(6) - 8、5(處理值)
(5)~(8)~(7)~(2)~(3)~(9)~(4)~(6) - 8、7(處理值)
(5)~(7)~(8)~(2)~(3)~(9)~(4)~(6) - 8、2(處理值)
(5)~(7)~(2)~(8)~(3)~(9)~(4)~(6) - 8、3(處理值)
(5)~(7)~(2)~(3)~(8)~(9)~(4)~(6) - 8、9(處理值)
(5)~(7)~(2)~(3)~(8)~(9)~(4)~(6) - 9、4(處理值)
(5)~(7)~(2)~(3)~(8)~(4)~(9)~(6) - 9、6(處理值)
(5)~(7)~(2)~(3)~(8)~(4)~(6)~(9)
```

``` Step2
(5)~(7)~(2)~(3)~(8)~(4)~(6)~(9) - 5、7(處理值)
(5)~(7)~(2)~(3)~(8)~(4)~(6)~(9) - 7、2(處理值)
(5)~(2)~(7)~(3)~(8)~(4)~(6)~(9) - 7、3(處理值)
(5)~(2)~(3)~(7)~(8)~(4)~(6)~(9) - 7、8(處理值)
(5)~(2)~(3)~(7)~(8)~(4)~(6)~(9) - 8、4(處理值)
(5)~(2)~(3)~(7)~(4)~(8)~(6)~(9) - 8、6(處理值)
(5)~(2)~(3)~(7)~(4)~(6)~(8)~(9)
```

``` Step3
(5)~(2)~(3)~(7)~(4)~(6)~(8)~(9) - 5、2(處理值)
(2)~(5)~(3)~(7)~(4)~(6)~(8)~(9) - 5、3(處理值)
(2)~(3)~(5)~(7)~(4)~(6)~(8)~(9) - 5、7(處理值)
(2)~(3)~(5)~(7)~(4)~(6)~(8)~(9) - 7、4(處理值)
(2)~(3)~(5)~(4)~(7)~(6)~(8)~(9) - 7、6(處理值)
(2)~(3)~(5)~(4)~(6)~(7)~(8)~(9)
```

``` Step4
(2)~(3)~(5)~(4)~(6)~(7)~(8)~(9) - 2、3(處理值)
(2)~(3)~(5)~(4)~(6)~(7)~(8)~(9) - 3、5(處理值)
(2)~(3)~(5)~(4)~(6)~(7)~(8)~(9) - 5、4(處理值)
(2)~(3)~(4)~(5)~(6)~(7)~(8)~(9) - 5、6(處理值)
(2)~(3)~(4)~(5)~(6)~(7)~(8)~(9)
```

```js
function swap(arr, i, j) {
    let tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function bubbleSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        let swap = false;
        for (let j = 0; j < arr.length - i; j++) {
            if (arr[j] > arr[j + 1]) {
                let tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
                swap = true;
            }
        }
        if (!swap) {
            break;
        }
    }
}
```

`swap`：檢查是否已經完成排序，如果都沒有執行交換，代表已完成可以提前結束排序。

# 插入排序法 ( Insertion Sort )
> 

### 時間複雜度 ( Time Complexity )
* Best Case：Ο(1)
* Worst Case：Ο(n2)
* Average Case：Ο(n2)

``` Step1
(8)~(5)~(7)~(2)~(3)~(9)~(4)~(6) - 8(處理值)
```

``` Step2
(8)~(5)~(7)~(2)~(3)~(9)~(4)~(6) - 5(處理值)
(5)~(8)~(7)~(2)~(3)~(9)~(4)~(6)
```

``` Step3
(5)~(8)~(7)~(2)~(3)~(9)~(4)~(6) - 7(處理值)
(5)~(7)~(8)~(2)~(3)~(9)~(4)~(6)
```

``` Step4
(5)~(7)~(8)~(2)~(3)~(9)~(4)~(6) - 2(處理值)
(5)~(7)~(2)~(8)~(3)~(9)~(4)~(6)
(5)~(2)~(7)~(8)~(3)~(9)~(4)~(6)
(2)~(5)~(7)~(8)~(3)~(9)~(4)~(6)
```

``` Step5
(2)~(5)~(7)~(8)~(3)~(9)~(4)~(6) - 3(處理值)
(2)~(5)~(7)~(3)~(8)~(9)~(4)~(6)
(2)~(5)~(3)~(7)~(8)~(9)~(4)~(6)
(2)~(3)~(5)~(7)~(8)~(9)~(4)~(6)
```

``` Step6
(2)~(3)~(5)~(7)~(8)~(9)~(4)~(6) - 4(處理值)
(2)~(3)~(5)~(7)~(8)~(4)~(9)~(6)
(2)~(3)~(5)~(7)~(4)~(8)~(9)~(6)
(2)~(3)~(5)~(4)~(7)~(8)~(9)~(6)
(2)~(3)~(4)~(5)~(7)~(8)~(9)~(6)
```

``` Step7
(2)~(3)~(4)~(5)~(7)~(8)~(9)~(6) - 6(處理值)
(2)~(3)~(4)~(5)~(7)~(8)~(6)~(9)
(2)~(3)~(4)~(5)~(7)~(6)~(8)~(9)
(2)~(3)~(4)~(5)~(6)~(7)~(8)~(9)
```

```js
function swap(arr, i, j) {
    let tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function insertion(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i; j >= 0; j--) {
            if (arr[j + 1] < arr[j]) {
                swap(arr, j, j + 1)
            } else {
                continue;
            }
        }
    }
}
```

# 選擇排序法 ( Selection Sort )
> 搜尋最小值，與第一值交換位置，再找第二個最小值，與第二個值交換位置，以此類推，直到排序完成。

### 時間複雜度 ( Time Complexity )
* Best Case：Ο(n2)
* Worst Case：Ο(n2)
* Average Case：Ο(n2)

### 空間複雜度 ( Space Complexity )
* θ(1)

``` Step1
(8)~(5)~(7)~(2)~(3)~(9)~(4)~(6) - 2(處理值)
(2)~(5)~(7)~(8)~(3)~(9)~(4)~(6)
```

``` Step2
(2)~(5)~(7)~(8)~(3)~(9)~(4)~(6) - 3(處理值)
(2)~(3)~(7)~(8)~(5)~(9)~(4)~(6)
```

``` Step3
(2)~(3)~(7)~(8)~(5)~(9)~(4)~(6) - 4(處理值)
(2)~(3)~(4)~(8)~(5)~(9)~(7)~(6)
```

``` Step4
(2)~(3)~(4)~(8)~(5)~(9)~(7)~(6) - 5(處理值)
(2)~(3)~(4)~(5)~(8)~(9)~(7)~(6)
```

``` Step5
(2)~(3)~(4)~(5)~(8)~(9)~(7)~(6) - 6(處理值)
(2)~(3)~(4)~(5)~(6)~(9)~(7)~(8)
```

``` Step6
(2)~(3)~(4)~(5)~(6)~(9)~(7)~(8) - 7(處理值)
(2)~(3)~(4)~(5)~(6)~(7)~(9)~(8)
```

``` Step7
(2)~(3)~(4)~(5)~(6)~(7)~(9)~(8) - 8(處理值)
(2)~(3)~(4)~(5)~(6)~(7)~(8)~(9)
```

```js
function swap(arr, i, j) {
    let tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function selection(arr) {
    let tmp = [];
    for (let i = 0; i < arr.length; i++) {
        let min = i;
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[min] > arr[j]) {
                min = j;
            }
        }
        if (i != min) {
            swap(arr, min, i);
        }
    }
}
```

# 希爾排序法 ( Shell Sort )
> 將序列先每隔 Gap 取出來先做 Insertion Sort ，一般 Gap 會設定成總長度的一半，假設序列長度為 10，一開始就以 5 當作 Gap ，所以每隔 5 的值為一組做 Insertion Sort，完成後，再將5的一半當作 Gap，也就是 2 當作 Gap 再做一次，以此類推，直到 Gap 等於 1 為止。

### 時間複雜度 ( Time Complexity )
* Best Case：Ο(n)
* Worst Case：Ο(n2) ~ Ο(n1.5)
* Average Case：Ο(n5/4)


``` Step1-Gap5
(8)~(5)~(7)~(2)~(3)~(9)~(4)~(6)~(1)~(0) - 8、9(處理值)
(8)~(5)~(7)~(2)~(3)~(9)~(4)~(6)~(1)~(0)

(8)~(5)~(7)~(2)~(3)~(9)~(4)~(6)~(1)~(0) - 5、4(處理值)
(8)~(4)~(7)~(2)~(3)~(9)~(5)~(6)~(1)~(0)

(8)~(4)~(7)~(2)~(3)~(9)~(5)~(6)~(1)~(0) - 7、6(處理值)
(8)~(4)~(6)~(2)~(3)~(9)~(5)~(7)~(1)~(0)

(8)~(4)~(6)~(2)~(3)~(9)~(5)~(7)~(1)~(0) - 2、1(處理值)
(8)~(4)~(6)~(1)~(3)~(9)~(5)~(7)~(2)~(0)

(8)~(4)~(6)~(1)~(3)~(9)~(5)~(7)~(2)~(0) - 3、0(處理值)
(8)~(4)~(6)~(1)~(0)~(9)~(5)~(7)~(2)~(3)
```

``` Step2-Gap2
(8)~(4)~(6)~(1)~(0)~(9)~(5)~(7)~(2)~(3) - 8、6、0、5、2(處理值)
(0)~(4)~(2)~(1)~(5)~(9)~(6)~(7)~(8)~(3)

(0)~(4)~(2)~(1)~(5)~(9)~(6)~(7)~(8)~(3) - 4、1、9、7、3(處理值)
(0)~(1)~(2)~(3)~(5)~(4)~(6)~(7)~(8)~(9)
```

``` Step2-Gap1
(0)~(1)~(2)~(3)~(5)~(4)~(6)~(7)~(8)~(9) - (Insertion Sort)
(0)~(1)~(2)~(3)~(4)~(5)~(6)~(7)~(8)~(9)
```

```js
function swap(arr, i, j) {
    let tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function insertion_with_gap(arr, start, gap) {
    for (let i = start; i < arr.length; i += gap) {
        for (let j = i; j >= 0; j -= gap) {
            if (arr[j + gap] < arr[j]) {
                swap(arr, j, j + gap)
            } else {
                continue;
            }
        }
    }
}

function shell(arr) {
    console.log(arr);
    let length = arr.length;
    for (gap = parseInt(length / 2); gap > 0; gap = parseInt(gap / 2)) {
        for (let i = 0; i < gap; i++) {
            insertion_with_gap(arr, i, gap);
        }
        console.log(arr);
    }
}
```

# 快速排序法 ( Quick Sort with In-Place)
>


``` Step1
(8)~(5)~(7)~(2)~(3)~(9)~(4)~(6)~(1)~(0) - 8(基準值)
(8)~(5)~(7)~(2)~(3)~(9)~(4)~(6)~(1)~(0) - 9(大於基準值)與索引位置(9)互換
(8)~(5)~(7)~(2)~(3)~(0)~(4)~(6)~(1)~(9) - 交換完畢索引位置減一(8)
(8)~(5)~(7)~(2)~(3)~(0)~(4)~(6)~(1)~(9) - 沒有發現比基準值大的數，基準值與索引位置(8)交換
(1)~(5)~(7)~(2)~(3)~(0)~(4)~(6)~(8)~(9) - 交換完畢
[(1)~(5)~(7)~(2)~(3)~(0)~(4)~(6)]~(8)~[(9)]
```

``` Step2
(1)~(5)~(7)~(2)~(3)~(0)~(4)~(6) - 1(基準值)
(1)~(5)~(7)~(2)~(3)~(0)~(4)~(6) - 6(大於基準值)與索引位置(7)互換
(1)~(5)~(7)~(2)~(3)~(0)~(4)~(6) - 交換完畢索引位置減一(6)
(1)~(5)~(7)~(2)~(3)~(0)~(4)~(6) - 4(大於基準值)與索引位置(6)互換
(1)~(5)~(7)~(2)~(3)~(0)~(4)~(6) - 交換完畢索引位置減一(5)
(1)~(5)~(7)~(2)~(3)~(0)~(4)~(6) - 3(大於基準值)與索引位置(5)互換
(1)~(5)~(7)~(2)~(0)~(3)~(4)~(6) - 交換完畢索引位置減一(4)
(1)~(5)~(7)~(2)~(0)~(3)~(4)~(6) - 2(大於基準值)與索引位置(4)互換
(1)~(5)~(7)~(0)~(2)~(3)~(4)~(6) - 交換完畢索引位置減一(3)
(1)~(5)~(7)~(0)~(2)~(3)~(4)~(6) - 7(大於基準值)與索引位置(3)互換
(1)~(5)~(0)~(7)~(2)~(3)~(4)~(6) - 交換完畢索引位置減一(2)
(1)~(5)~(0)~(7)~(2)~(3)~(4)~(6) - 5(大於基準值)與索引位置(2)互換
(1)~(0)~(5)~(7)~(2)~(3)~(4)~(6) - 交換完畢索引位置減一(1)
(1)~(0)~(5)~(7)~(2)~(3)~(4)~(6) - 沒有發現比基準值大的數，基準值與索引位置(1)交換
(0)~(1)~(5)~(7)~(2)~(3)~(4)~(6) - 交換完畢
[(0)]~(1)~[(5)~(7)~(2)~(3)~(4)~(6)]
```

```js
function quick_sort(arr) {
    let len = arr.length;
    if (len <= 1)
        return arr.slice(0);
    let left = [];
    let right = [];
    let pivot = [arr[0]];
    for (let i = 1; i < len; i++)
        if (arr[i] < pivot[0])
            left.push(arr[i]);
        else
            right.push(arr[i]);
    return quick_sort(left).concat(pivot.concat(quick_sort(right)));
};
```

```js
function quick_sort_in_place(arr) {
    function swap(arr, i, j) {
        let tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    };

    function partition(arr, left, right) {
        let pivot = arr[left];
        let storeIndex = right;
        for (let i = right; i > left; i--) {
            if (arr[i] > pivot) {
                swap(arr, i, storeIndex);
                storeIndex--;
            }
        }
        swap(arr, storeIndex, left);
        return storeIndex;
    }

    function sort(arr, left, right) {
        if (left > right) {
            return;
        }

        let storeIndex = partition(arr, left, right);
        sort(arr, left, storeIndex - 1);
        sort(arr, storeIndex + 1, right);
    }

    sort(arr, 0, arr.length - 1);
}
```